{"id":"82kPqoBYiySD8ih7nAXkFuDhjyLjtPi8jr6gSpxV4VMW","title":"The Go Blog","displayTitle":"Dev - Golang Blog","url":"http://blog.golang.org/feed.atom","feedLink":"http://blog.golang.org/feed.atom","items":[{"title":"Go Developer Survey 2024 H2 Results","url":"https://go.dev/blog/survey2024-h2-results","date":1734652800,"author":"Alice Merrick","unread":true,"desc":"","content":"\n<div id=\"blog\"><div id=\"content\">\n  <div id=\"content\">\n\n    <div class=\"Article\" data-slug=\"/blog/survey2024-h2-results\">\n    \n    <h1 class=\"small\"><a href=\"/blog/\">The Go Blog</a></h1>\n    \n\n    <h1>Go Developer Survey 2024 H2 Results</h1>\n      \n      <p class=\"author\">\n      Alice Merrick<br>\n      20 December 2024\n      </p>\n      \n      <style type=\"text/css\" scoped>\n  .chart {\n    margin-left: 1.5rem;\n    margin-right: 1.5rem;\n    width: 800px;\n  }\n  blockquote p {\n    color: var(--color-text-subtle) !important;\n  }\n\n  .quote_source {\n    font-style: italic;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    .chart {\n      border-radius: 8px;\n    }\n  }\n</style>\n<h2 id=\"background\">Background</h2>\n<p>Go was designed with a focus on developer experience, and we deeply value the\nfeedback we receive through proposals, issues, and community interactions.\nHowever, these channels often represent the voices of our most experienced or\nengaged users, a small subset of the broader Go community. To ensure we&rsquo;re\nserving developers of all skill levels, including those who may not have strong\nopinions on language design, we conduct this survey once or twice a year to\ngather systematic feedback and quantitative evidence. This inclusive approach\nallows us to hear from a wider range of Go developers, providing valuable\ninsights into how Go is used across different contexts and experience levels.\nYour participation is critical in informing our decisions about language changes\nand resource allocation, ultimately shaping the future of Go. Thank you to\neveryone who contributed, and we strongly encourage your continued participation\nin future surveys. Your experience matters to us.</p>\n<p>This post shares the results of our most recent Go Developer Survey, conducted\nfrom September 9–23, 2024. We recruited participants from the Go blog and\nthrough randomized prompts in the <a href=\"https://code.visualstudio.com/\" rel=\"noreferrer\" target=\"_blank\">VS Code</a> Go\nplug-in and <a href=\"https://www.jetbrains.com/go/\" rel=\"noreferrer\" target=\"_blank\">GoLand IDE</a>, allowing us to recruit\na more representative sample of Go developers. We received a total of 4,156\nresponses. A huge thank you to all those who contributed to making this\npossible.</p>\n<p>Along with capturing sentiments and challenges around using Go and Go tooling,\nour primary focus areas for this survey were on uncovering sources of toil,\nchallenges to performing best practices, and how developers are using AI\nassistance.</p>\n<h2 id=\"highlights\">Highlights</h2>\n<ul>\n<li><strong>Developer sentiment towards Go remains extremely positive</strong>, with 93% of\nsurvey respondents saying they felt satisfied while working with Go during the\nprior year.</li>\n<li><strong>Ease of deployment and an easy to use API/SDK</strong> were respondents’ favorite\nthings about using Go on the top three cloud providers. First-class Go support\nis critical to keeping up with developer expectations.</li>\n<li>70% of respondents were using AI assistants when developing with Go. The most\ncommon uses were <strong>LLM-based code completion</strong>, writing tests, generating Go\ncode from natural language descriptions, and brainstorming. There was a\nsignificant discrepancy between what respondents said they wanted to use AI\nfor last year, and what they currently use AI for.</li>\n<li>The biggest challenge for teams using Go was <strong>maintaining consistent coding\nstandards</strong> across their codebase. This was often due to team members having\ndifferent levels of Go experience and coming from different programming\nbackgrounds, leading to inconsistencies in coding style and adoption of\nnon-idiomatic patterns.</li>\n</ul>\n<h2 id=\"contents\">Contents</h2>\n<ul>\n<li><a href=\"#sentiment\">Overall satisfaction</a></li>\n<li><a href=\"#devenv\">Development environments and tools</a></li>\n<li><a href=\"#cloud\">Go in the clouds</a></li>\n<li><a href=\"#ai-assistance\">AI assistance</a></li>\n<li><a href=\"#team-challenges\">Challenges for teams using Go</a></li>\n<li><a href=\"#simd\">Single Instruction, Multiple Data (SIMD)</a></li>\n<li><a href=\"#demographics\">Demographics</a></li>\n<li><a href=\"#firmographics\">Firmographics</a></li>\n<li><a href=\"#methodology\">Methodology</a></li>\n<li><a href=\"#how-to-read-these-results\">How to read these results</a></li>\n<li><a href=\"#closing\">Closing</a></li>\n</ul>\n<h3 id=\"sentiment\">Overall satisfaction</h3>\n<p>Overall satisfaction remains high in the survey with 93% of respondents saying\nthey were somewhat or very satisfied with Go during the last year. Although the\nexact percentages fluctuate slightly from cycle to cycle, we do not see any\nstatistically significant differences from our <a href=\"/blog/survey2023-h2-results\">2023\nH2</a> or <a href=\"/blog/survey2024-h1-results\">2024 H1\n</a>Surveys when the satisfaction rate\nwas 90% and 93%, respectively.</p>\n<p><img src=\"survey2024h2/csat.svg\" alt=\"Chart of developer satisfaction with Go\"\nclass=\"chart\" /></p>\n<p>The open comments we received on the survey continue to highlight what\ndevelopers like most about using Go, for example, its simplicity, the Go\ntoolchain, and its promise of backwards compatibility:</p>\n<p><em>“I am a programming languages enjoyer (C-like) and I always come back to Go for\nits simplicity, fast compilation and robust toolchain. Keep it up!”</em></p>\n<p><em>“Thank you for creating Go! It is my favorite language, because it is pretty\nminimal, the development cycle has rapid build-test cycles, and when using a\nrandom open source project written in Go, there is a good chance that it will\nwork, even 10 years after. I love the 1.0 compatibility guarantee.”</em></p>\n<h3 id=\"devenv\">Development environments and tools</h3>\n<h4 id=\"developer-os\">Developer OS</h4>\n<p>Consistent with previous years, most survey respondents develop with Go on Linux\n(61%) and macOS (59%) systems. Historically, the proportion of Linux and macOS\nusers has been very close, and we didn’t see any significant changes from the\nlast survey. The randomly sampled groups from JetBrains and VS Code were more\nlikely (33% and 36%, respectively) to develop on Windows than the self-selected\ngroup (16%).</p>\n<p><img src=\"survey2024h2/os_dev.svg\" alt=\"Chart of operating systems respondents\nuse when developing Go software\" class=\"chart\" /> <img\nsrc=\"survey2024h2/os_dev_src.svg\" alt=\"Chart of operating systems respondents\nuse when developing Go software, split by difference sample sources\"\nclass=\"chart\" /></p>\n<h4 id=\"deployment-environments\">Deployment environments</h4>\n<p>Given the prevalence of Go for cloud development and containerized workloads,\nit’s no surprise that Go developers primarily deploy to Linux environments\n(96%).</p>\n<p><img src=\"survey2024h2/os_deploy.svg\" alt=\"Chart of operating systems\nrespondents deploy to when developing Go software\" class=\"chart\" /></p>\n<p>We included several questions to understand what architectures respondents are\ndeploying to when deploying to Linux, Windows or WebAssembly. The x86-64 /\nAMD64 architecture was by far the most popular choice for those deploying to\nboth Linux (92%) and Windows (97%). ARM64 was second at 49% for Linux and 21%\nfor Windows.</p>\n<p><img src=\"survey2024h2/arch_linux.svg\" alt=\"Linux architecture usage\"\nclass=\"chart\" /> <img src=\"survey2024h2/arch_win.svg\" alt=\"Windows architecture\nusage\" class=\"chart\" /></p>\n<p>Not many respondents deployed to Web Assembly (only about 4% of overall\nrespondents), but 73% that do said they deploy to JS and 48% to WASI Preview 1.</p>\n<p><img src=\"survey2024h2/arch_wa.svg\" alt=\"Web assembly architecture usage\"\nclass=\"chart\" /></p>\n<h4 id=\"editor-awareness-and-preferences\">Editor awareness and preferences</h4>\n<p>We introduced a new question on this survey to assess awareness and usage of\npopular editors for Go. When interpreting these results, keep in mind that 34%\nof respondents came to the survey from VS Code and 9% of respondents came from\nGoLand, so it is more likely for them to use those editors regularly.</p>\n<p>VS Code was the most widely used editor, with 66% of respondents using it\nregularly, and GoLand was the second most used at 35%. Almost all respondents\nhad heard of both VS Code and GoLand, but respondents were much more likely to\nhave at least tried VS Code. Interestingly, 33% of respondents said they\nregularly use 2 or more editors. They may use different editors for different\ntasks or environments, such as using Emacs or Vim via SSH, where IDEs aren’t\navailable.</p>\n<p><img src=\"survey2024h2/editor_aware.svg\" alt=\"Level of familiarity with each\neditor\" class=\"chart\" /></p>\n<p>We also asked a question about editor preference, the same as we have asked on\nprevious surveys. Because our randomly sampled populations were recruited from\nwithin VS Code or GoLand, they are strongly biased towards preferring those\neditors. To avoid skewing the results, we show the data for the most preferred\neditor here from the self-selected group only. 38% preferred VS Code and 35%\npreferred GoLand. This is a notable difference from the last survey in H1, when\n43% preferred VS Code and 33% preferred GoLand. A possible explanation could be\nin how respondents were recruited this year. This year the VS Code notification\nbegan inviting developers to take the survey before the Go blog entry was\nposted, so a larger proportion of respondents came from the VS Code prompt this\nyear who might have otherwise come from the blog post. Because we only show the\nself-selected respondents in this chart, data from respondents from the VS Code\nprompt data are not represented here. Another contributing factor could be the\nslight increase in those who prefer &ldquo;Other&rdquo; (4%). The write-in responses suggest\nthere is increased interest in editors like <a href=\"https://zed.dev/\" rel=\"noreferrer\" target=\"_blank\">Zed</a>, which made\nup 43% of the write-in responses.</p>\n<p><img src=\"survey2024h2/editor.svg\" alt=\"Code editors respondents most prefer to\nuse with Go\" class=\"chart\" /></p>\n<h4 id=\"code-analysis-tools\">Code analysis tools</h4>\n<p>The most popular code analysis tool was <code>gopls</code>, which was knowingly used by 65%\nof respondents. Because <code>gopls</code> is used under-the-hood by default in VS Code,\nthis is likely an undercount. Following closely behind, <code>golangci-lint</code> was used\nby 57% of respondents, and <code>staticcheck</code> was used by 34% of respondents. A much\nsmaller proportion used custom or other tools, which suggests that most\nrespondents prefer common established tools over custom solutions. Only 10% of\nrespondents indicated they don&rsquo;t use any code analysis tools.</p>\n<p><img src=\"survey2024h2/code_analysis.svg\" alt=\"Code analysis tools respondents\nuse with Go\" class=\"chart\" /></p>\n<h4 id=\"cloud\">Go in the Clouds</h4>\n<p>Go is a popular language for modern cloud-based development, so we typically\ninclude survey questions to help us understand which cloud platforms and\nservices Go developers are using. In this cycle, we sought to learn about\npreferences and experiences of Go developers across cloud providers, with a\nparticular focus on the largest cloud providers: Amazon Web Services (AWS),\nMicrosoft Azure, and Google Cloud. We also included an additional option for\n“Bare Metal Servers” for those who deploy to servers without virtualization.</p>\n<p>Similar to previous years, almost half of respondents (50%) deploy Go programs\nto Amazon Web Services. AWS is followed by self-owned or company-owned servers\n(37%), and Google Cloud (30%). Respondents who work at large organizations are a\nlittle more likely to deploy to self-owned or company-owned servers (48%) than\nthose who work at small-to-medium organizations (34%). They‘re also a little\nmore likely to deploy to Microsoft Azure (25%) than small-to-medium\norganizations (12%).</p>\n<p><img src=\"survey2024h2/cloud_platform.svg\" alt=\"Cloud providers where\nrespondents deploy Go software\" class=\"chart\" /></p>\n<p>The most commonly used cloud services were AWS Elastic Kubernetes Service (41%),\nAWS EC2 (39%), and Google Cloud GKE (29%). Although we’ve seen Kubernetes usage\nincrease over time, this is the first time we’ve seen EKS become more widely\nused than EC2. Overall, Kubernetes offerings were the most popular services for\nAWS, Google Cloud, and Azure, followed by VMs and then Serverless offerings.\nGo&rsquo;s strengths in containerization and microservices development naturally align\nwith the rising popularity of Kubernetes, as it provides an efficient and\nscalable platform for deploying and managing these types of applications.</p>\n<p><img src=\"survey2024h2/cloud_service.svg\" alt=\"Cloud platforms where respondents\ndeploy Go software\" class=\"chart\" /></p>\n<p>We asked a followup question to respondents who deployed Go code to the top\nthree cloud providers, Amazon Web Services, Google Cloud, and Microsoft Azure on\nwhat they like most about deploying Go code to each cloud. The most popular\nresponse across different providers was actually Go&rsquo;s performance and language\nfeatures rather than something about the cloud provider.</p>\n<p>Other common reasons were:</p>\n<ul>\n<li>Familiarity with the given cloud provider compared to other clouds</li>\n<li>Ease of deployment of Go applications on the given cloud provider</li>\n<li>The cloud provider&rsquo;s API/SDK for Go is easy to use</li>\n<li>The API/SDK is well documented</li>\n</ul>\n<p>Other than familiarity, the top favorite things highlight the importance of\nhaving first class support for Go to keep up with developer expectations.</p>\n<p>It was also fairly common for respondents to say they don&rsquo;t have a favorite\nthing about their cloud provider. From a previous version of the survey that\ninvolved write-in responses, this often meant that they did not interact\ndirectly with the Cloud. In particular, respondents who use Microsoft Azure were\nmuch more likely to say that “Nothing” was their favorite thing (51%) compared\nto AWS (27%) or Google Cloud (30%).</p>\n<p><img src=\"survey2024h2/cloud_fave_all.svg\" alt= \"What respondents liked most\nabout each of the top 3 Clouds\" class=\"chart\" /></p>\n<h3 id=\"ai-assistance\">AI assistance</h3>\n<p>The Go team hypothesizes that AI assistance has the potential to alleviate\ndevelopers from tedious and repetitive tasks, allowing them to focus on more\ncreative and fulfilling aspects of their work. To gain insights into areas where\nAI assistance could be most beneficial, we included a section in our survey to\nidentify common developer toil.</p>\n<p>The majority of respondents (70%) are using AI assistants when developing with\nGo. The most common usage of AI assistants was in LLM-based code completion\n(35%). Other common responses were writing tests (29%), generating Go code from\na natural language description (27%), and brainstorming ideas (25%). There was\nalso a sizable minority (30%) of respondents who had not used any LLM for\nassistance in the last month.</p>\n<p><img src=\"survey2024h2/ai_assist_tasks.svg\" alt= \"Most common tasks used with AI\nassistance\" class=\"chart\" /></p>\n<p>Some of these results stood out when compared to findings from our 2023 H2\nsurvey, where we asked respondents for the top 5 use cases they would like to\nsee AI/ML support Go developers. Although a couple new responses were introduced\nin the current survey, we can still do a rough comparison between what\nrespondents said they wanted AI support for, and what their actual usage was\nlike. In that previous survey, writing tests was the most desired use case\n(49%). In our latest 2024 H2 survey, about 29% of respondents had used AI\nassistants for this in the last month. This suggests that current offerings are\nnot meeting developer needs for writing tests. Similarly, in 2023, 47%\nrespondents said they would like suggestions for best practices while coding,\nwhile only 14% a year later said they are using AI assistance for this use case.\n46% said they wanted help catching common mistakes while coding, and only 13%\nsaid they were using AI assistance for this. This could indicate that current AI\nassistants are not well-equipped for these kinds of tasks, or they&rsquo;re not well\nintegrated into developer workflows or tooling.</p>\n<p>It was also surprising to see such high usage of AI for generating Go code from\nnatural language and brainstorming, since the previous survey didn&rsquo;t indicate\nthese as highly desired use cases. There could be a number of explanations for\nthese differences. While previous respondents might not have explicitly <em>wanted</em>\nAI for code generation or brainstorming initially, they might be gravitating\ntowards these uses because they align with the current strengths of generative\nAI—natural language processing and creative text generation. We should also keep\nin mind that people<a href=\"https://www.nngroup.com/articles/first-rule-of-usability-dont-listen-to-users/\" rel=\"noreferrer\" target=\"_blank\"> are not necessarily the best predictors of their own\nbehavior</a>.</p>\n<p><img src=\"survey2024h2/ai_assist_tasks_yoy.svg\" alt= \"Tasks used AI assistance\nin 2024 compared to those wanted in 2023\" class=\"chart\" /></p>\n<p>We also saw some notable differences in how different groups responded to this\nquestion. Respondents at small to medium sized organizations were a little more\nlikely to have used LLMs (75%) compared to those at large organizations (66%).\nThere could be a number of reasons why, for example, larger organizations may\nhave stricter security and compliance requirements and concerns about the\nsecurity of LLM coding assistants, the potential for data leakage, or compliance\nwith industry-specific regulations. They also may have already invested in\nother developer tools and practices that already provide similar benefits to\ndeveloper productivity.</p>\n<p><img src=\"survey2024h2/ai_assist_tasks_org.svg\" alt= \"Most common tasks used\nwith AI assistance by org size\" class=\"chart\" /></p>\n<p>Go developers with less than 2 years of experience were more likely to use AI\nassistants (75%) compared to Go developers with 5+ years of experience (67%).\nLess experienced Go developers were also more likely to use them for more tasks,\non average 3.50. Although all experience levels tended to use LLM-based code\ncompletion, less experienced Go developers were more likely to use Go for more\ntasks related to learning and debugging, such as explaining what a piece of Go\ncode does, resolving compiler errors and debugging failures in their Go code.\nThis suggests that AI assistants are currently providing the greatest utility to\nthose who are less familiar with Go. We don&rsquo;t know how AI assistants affect\nlearning or getting started on a new Go project, something we want to\ninvestigate in the future. However, all experience levels had similar rates of\nsatisfaction with their AI assistants, around 73%, so new Go developers are not\nmore satisfied with AI assistants, despite using them more often.</p>\n<p><img src=\"survey2024h2/ai_assist_tasks_exp.svg\" alt= \"Most common tasks used\nwith AI assistance by experience with Go\" class=\"chart\" /></p>\n<p>To respondents who reported using AI assistance for at least one task related to\nwriting Go code, we asked some follow up questions to learn more about their AI\nassistant usage. The most commonly used AI assistants were ChatGPT (68%) and\nGitHub Copilot (50%). When asked which AI assistant they used <em>most</em> in the last\nmonth, ChatGPT and Copilot were about even at 36% each, so although more\nrespondents used ChatGPT, it wasn’t necessarily their primary assistant.\nParticipants were similarly satisfied with both tools (73% satisfied with\nChatGPT, vs. 78% with GitHub CoPilot). The highest satisfaction rate for any AI\nassistant was Anthropic Claude, at 87%.</p>\n<p><img src=\"survey2024h2/ai_assistants_withother.svg\" alt= \"Most common AI\nassistants used\" class=\"chart\" /> <img src=\"survey2024h2/ai_primary.svg\" alt=\n\"Most common primary AI assistants used\" class=\"chart\" /></p>\n<h3 id=\"team-challenges\">Challenges for teams using Go</h3>\n<p>In this section of the survey, we wanted to understand which best practices or\ntools should be better integrated into developer workflows. Our approach was to\nidentify common problems for teams using Go. We then asked respondents which\nchallenges would bring them the most benefit if they were “magically” solved for\nthem. (This was so that respondents would not focus on particular solutions.)\nCommon problems that would provide the most benefit if they were solved would be\nconsidered candidates for improvement.</p>\n<p>The most commonly reported challenges for teams were maintaining consistent coding\nstandards across our Go codebase (58%), identifying performance issues in a\nrunning Go program (58%) and identifying resource usage inefficiencies in a\nrunning Go program (57%).</p>\n<p><img src=\"survey2024h2/dev_challenges.svg\" alt= \"Most common challenges for\nteams\" class=\"chart\" /></p>\n<p>21% of respondents said their team would benefit most from maintaining\nconsistent coding standards across their Go codebase. This was the most common\nresponse, making it a good candidate to address. In a follow-up question, we got\nmore details as to why specifically this was so challenging.</p>\n<p><img src=\"survey2024h2/dev_challenges_most_benefit.svg\" alt= \"Most benefit to\nsolve\" class=\"chart\" /></p>\n<p>According to the write-in responses, many teams face challenges maintaining\nconsistent coding standards because their members have varying levels of\nexperience with Go and come from different programming backgrounds. This led to\ninconsistencies in coding style and the adoption of non-idiomatic patterns.</p>\n<p><em>“There&rsquo;s lots of polyglot engineers where I work. So the Go written is not\nconsistent. I do consider myself a Gopher and spend time trying to convince my\nteammates what is idiomatic in Go”—Go developer with 2–4 years of experience.</em></p>\n<p><em>“Most of the team members are learning Go from scratch. Coming from the\ndynamically typed languages, it takes them a while to get used to the new\nlanguage. They seem to struggle maintaining the code consistency following the\nGo guidelines.”—Go developer with 2–4 years of experience.</em></p>\n<p>This echoes some feedback we’ve heard before about teammates who write &ldquo;Gava&rdquo; or\n&ldquo;Guby&rdquo; due to their previous language experiences. Although static analysis was\na class of tool we had in mind to address this issue when we came up with this\nquestion, we are currently exploring different ways we might address this.</p>\n<h3 id=\"simd\">Single Instruction, Multiple Data (SIMD)</h3>\n<p>SIMD, or Single Instruction, Multiple Data, is a type of parallel processing\nthat allows a single CPU instruction to operate on multiple data points\nsimultaneously. This facilitates tasks involving large datasets and repetitive\noperations, and is often used to optimize performance in fields like game\ndevelopment, data processing, and scientific computing. In this section of the\nsurvey we wanted to assess respondents&rsquo; needs for native SIMD support in Go.</p>\n<p>The majority of respondents (89%) say that work on projects where performance\noptimizations are crucial at least some of the time. 40% said they work on such\nprojects at least half the time. This held true across different organization\nsizes and experience levels, suggesting that performance is an important issue\nfor most developers.</p>\n<p><img src=\"survey2024h2/perf_freq.svg\" alt= \"How often respondents work on\nperformance critical software\" class=\"chart\" /></p>\n<p>About half of respondents (54%), said they are at least a little familiar with\nthe concept of SIMD. Working with SIMD often requires a deeper understanding of\ncomputer architecture and low-level programming concepts, so unsurprisingly we\nfind that less experienced developers were less likely to be familiar with SIMD.\nRespondents with more experience and who worked on performance-crucial\napplications at least half the time were the most likely to be familiar with\nSIMD.</p>\n<p><img src=\"survey2024h2/simd_fam.svg\" alt= \"Familiarity with SIMD\" class=\"chart\"\n/></p>\n<p>For those who were at least slightly familiar with SIMD, we asked some follow\n-up questions to understand how respondents were affected by the absence of\nnative SIMD support in Go. Over a third, about 37%, said they had been impacted.\n17% of respondents said they had been limited in the performance they could\nachieve in their projects, 15% said they had to use another language instead of\nGo to achieve their goals, and 13% said they had to use non-Go libraries when\nthey would have preferred to use Go libraries. Interestingly, respondents who\nwere negatively impacted by the absence of native SIMD support were a little\nmore likely to use Go for data processing and AI/ML. This suggests that adding\nSIMD support could make Go a better option for these domains.</p>\n<p><img src=\"survey2024h2/simd_impact.svg\" alt= \"Impacts of lack of native Go support\nfor SIMD\" class=\"chart\" /> <img src=\"survey2024h2/what_simd_impact.svg\" alt=\n\"What impacted respondents build with Go\" class=\"chart\" /></p>\n<h3 id=\"demographics\">Demographics</h3>\n<p>We ask similar demographic questions during each cycle of this survey so we can\nunderstand how comparable the year-over-year results may be. For example, if we\nsaw changes in who responded to the survey in terms of Go experience, it’d be\nvery likely that other differences in results from prior cycles were due to this\ndemographic shift. We also use these questions to provide comparisons between\ngroups, such as satisfaction according to how long respondents have been using\nGo.</p>\n<p>We didn’t see any significant changes in levels of experience among respondents\nduring this cycle.</p>\n<p><img src=\"survey2024h2/go_exp.svg\" alt= \"Experience levels of respondents\"\nclass=\"chart\" /></p>\n<p>There are differences in the demographics of respondents according to whether\nthey came from The Go Blog, the VS Code extension, or GoLand. The population\nwho responded to survey notifications in VS Code skews toward less experience\nwith Go; we suspect this a reflection of VS Code’s popularity with new Go\ndevelopers, who may not be ready to invest in an IDE license while they’re still\nlearning. With respect to years of Go experience, the respondents randomly\nselected from GoLand are more similar to our self-selected population who found\nthe survey through the Go Blog. Seeing consistencies between samples allows us\nto more confidently generalize findings to the rest of the community.</p>\n<p><img src=\"survey2024h2/go_exp_src.svg\" alt= \"Experience with Go by survey\nsource\" class=\"chart\" /></p>\n<p>In addition to years of experience with Go, we also measured years of\nprofessional coding experience. Our audience tends to be a pretty experienced\nbunch, with 26% of respondents having 16 or more years of professional coding\nexperience.</p>\n<p><img src=\"survey2024h2/dev_exp.svg\" alt= \"Overall levels of professional\ndeveloper experience\" class=\"chart\" /></p>\n<p>The self-selected group was even more experienced than the randomly selected\ngroups, with 29% having 16 or more years of professional experience. This\nsuggests that our self-selected group is generally more experienced than our\nrandomly selected groups and can help explain some of the differences we see in\nthis group.</p>\n<p><img src=\"survey2024h2/dev_exp_src.svg\" alt= \"Levels of professional developer\nexperience by survey source\" class=\"chart\" /></p>\n<p>We found that 81% of respondents were fully employed. When we look at our\nindividual samples, we see a small but significant difference within our\nrespondents from VS Code, who are slightly more likely to be students. This\nmakes sense given that VS Code is free.</p>\n<img src=\"survey2024h2/employment.svg\" alt= \"Employment status\" class=\"chart\" />\n<img src=\"survey2024h2/employment_src.svg\" alt= \"Employment status by survey\nsource\" class=\"chart\" />\n<p>Similar to previous years, the most common use cases for Go were API/RPC\nservices (75%) and command line tools (62%). More experienced Go developers\nreported building a wider variety of applications in Go. This trend was\nconsistent across every category of app or service. We did not find any notable\ndifferences in what respondents are building based on their organization size.\nRespondents from the random VS Code and GoLand samples did not display\nsignificant differences either.</p>\n<p><img src=\"survey2024h2/what.svg\" alt= \"What respondents build with Go\"\nclass=\"chart\" /></p>\n<h3 id=\"firmographics\">Firmographics</h3>\n<p>We heard from respondents at a variety of different organizations. About 29%\nworked at large organizations with 1,001 or more employees, 25% were from\nmidsize organizations of 101–1,000 employees, and 43% worked at smaller\norganizations with fewer than 100 employees. As in previous years, the most\ncommon industry people work in was technology (43%) while the second most common\nwas financial services (13%).</p>\n<p><img src=\"survey2024h2/org_size.svg\" alt= \"Organization sizes where respondents\nwork\" class=\"chart\" /> <img src=\"survey2024h2/industry.svg\" alt= \"Industries\nrespondents work in\" class=\"chart\" /></p>\n<p>As in previous surveys, the most common location for survey respondents was the\nUnited States (19%). This year we saw a significant shift in the proportion of\nrespondents coming from Ukraine, from 1% to 6%, making it the third most common\nlocation for survey respondents. Because we only saw this difference among our\nself-selected respondents, and not in the randomly sampled groups, this suggests\nthat something affected who discovered the survey, rather than a widespread\nincrease in Go adoption across all developers in Ukraine. Perhaps there was\nincreased visibility or awareness of the survey or the Go Blog among developers\nin Ukraine.</p>\n<p><img src=\"survey2024h2/location.svg\" alt= \"Where respondents are located\"\nclass=\"chart\" /></p>\n<h2 id=\"methodology\">Methodology</h2>\n<p>We announce the survey primarily through the Go Blog, where it is often picked\nup on various social channels like Reddit, or Hacker News. We also recruit\nrespondents by using the VS Code Go plugin to randomly select users to whom we show\na prompt asking if they’d like to participate in the survey. With some help from\nour friends at JetBrains, we also have an additional random sample from\nprompting a random subset of GoLand users to take the survey. This gave us two\nsources we used to compare the self-selected respondents from our traditional\nchannels and help identify potential effects of <a href=\"https://en.wikipedia.org/wiki/Self-selection_bias\" rel=\"noreferrer\" target=\"_blank\">self-selection\nbias</a>.</p>\n<p>57% of survey respondents “self-selected” to take the survey, meaning they found\nit on the Go blog or other social Go channels. People who don’t follow these\nchannels are less likely to learn about the survey from them, and in some cases,\nthey respond differently than people who do closely follow them. For example,\nthey might be new to the Go community and not yet aware of the Go blog. About\n43% of respondents were randomly sampled, meaning they responded to the survey\nafter seeing a prompt in VS Code (25%) or GoLand (11%). Over the period of\nSeptember 9–23, 2024, there was roughly a 10% chance users of the VS Code plugin\nwould have seen this prompt. The prompt in GoLand was similarly active between\nSeptember 9–20. By examining how the randomly sampled groups differ from the\nself-selected responses, as well as from each other, we’re able to more\nconfidently generalize findings to the larger community of Go developers.</p>\n<p><img src=\"survey2024h2/source.svg\" alt=\"Chart of different sources of survey\nrespondents\" class=\"chart\" /></p>\n<h4 id=\"how-to-read-these-results\">How to read these results</h4>\n<p>Throughout this report we use charts of survey responses to provide supporting\nevidence for our findings. All of these charts use a similar format. The title\nis the exact question that survey respondents saw. Unless otherwise noted,\nquestions were multiple choice and participants could only select a single\nresponse choice; each chart’s subtitle will tell the reader if the question\nallowed multiple response choices or was an open-ended text box instead of a\nmultiple choice question. For charts of open-ended text responses, a Go team\nmember read and manually categorized all of the responses. Many open-ended\nquestions elicited a wide variety of responses; to keep the chart sizes\nreasonable, we condensed them to a maximum of the top 10-12 themes, with\nadditional themes all grouped under “Other”. The percentage labels shown in\ncharts are rounded to the nearest integer (e.g., 1.4% and 0.8% will both be\ndisplayed as 1%), but the length of each bar and row ordering are based on the\nunrounded values.</p>\n<p>To help readers understand the weight of evidence underlying each finding, we\nincluded error bars showing the 95% <a href=\"https://en.wikipedia.org/wiki/Confidence_interval\" rel=\"noreferrer\" target=\"_blank\">confidence\ninterval</a> for responses;\nnarrower bars indicate increased confidence. Sometimes two or more responses\nhave overlapping error bars, which means the relative order of those responses\nis not statistically meaningful (i.e., the responses are effectively tied). The\nlower right of each chart shows the number of people whose responses are\nincluded in the chart, in the form “n = [number of respondents]”. In cases where\nwe found interesting differences in responses between groups, (e.g., years of\nexperience, organization size, or sample source) we showed a color-coded\nbreakdown of the differences.</p>\n<h3 id=\"closing\">Closing</h3>\n<p>Thanks for reviewing our semi-annual Go Developer Survey! And many thanks to\neveryone who shared their thoughts on Go and everyone who contributed to making\nthis survey happen. It means the world to us and truly helps us improve Go.</p>\n<p>&mdash; Alice (on behalf of the Go team at Google)</p>\n\n    </div>\n\n    \n    <div class=\"Article prevnext\">\n    \n    \n      \n        <p>\n        \n        \n          \n            <b>Previous article: </b><a href=\"/blog/protobuf-opaque\">Go Protobuf: The new Opaque API</a><br>\n          \n        \n        <b><a href=\"/blog/all\">Blog Index</a></b>\n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n    </div>\n    \n\n  </div>\n</div>\n\n<script src=\"/js/play.js\"></script>\n\n","flags":null,"enclosureUrl":"","enclosureMime":""},{"title":"Go Protobuf: The new Opaque API","url":"https://go.dev/blog/protobuf-opaque","date":1734307200,"author":"Michael Stapelberg","unread":true,"desc":"","content":"\n<div id=\"blog\"><div id=\"content\">\n  <div id=\"content\">\n\n    <div class=\"Article\" data-slug=\"/blog/protobuf-opaque\">\n    \n    <h1 class=\"small\"><a href=\"/blog/\">The Go Blog</a></h1>\n    \n\n    <h1>Go Protobuf: The new Opaque API</h1>\n      \n      <p class=\"author\">\n      Michael Stapelberg<br>\n      16 December 2024\n      </p>\n      \n      <p>[<a href=\"https://en.wikipedia.org/wiki/Protocol_Buffers\" rel=\"noreferrer\" target=\"_blank\">Protocol Buffers (Protobuf)</a>\nis Google&rsquo;s language-neutral data interchange format. See\n<a href=\"https://protobuf.dev/\" rel=\"noreferrer\" target=\"_blank\">protobuf.dev</a>.]</p>\n<p>Back in March 2020, we released the <code>google.golang.org/protobuf</code> module, <a href=\"/blog/protobuf-apiv2\">a\nmajor overhaul of the Go Protobuf API</a>. This\npackage introduced first-class <a href=\"https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect\" rel=\"noreferrer\" target=\"_blank\">support for\nreflection</a>,\na <a href=\"https://pkg.go.dev/google.golang.org/protobuf/types/dynamicpb\" rel=\"noreferrer\" target=\"_blank\"><code>dynamicpb</code></a>\nimplementation and the\n<a href=\"https://pkg.go.dev/google.golang.org/protobuf/testing/protocmp\" rel=\"noreferrer\" target=\"_blank\"><code>protocmp</code></a>\npackage for easier testing.</p>\n<p>That release introduced a new protobuf module with a new API. Today, we are\nreleasing an additional API for generated code, meaning the Go code in the\n<code>.pb.go</code> files created by the protocol compiler (<code>protoc</code>). This blog post\nexplains our motivation for creating a new API and shows you how to use it in\nyour projects.</p>\n<p>To be clear: We are not removing anything. We will continue to support the\nexisting API for generated code, just like we still support the older protobuf\nmodule (by wrapping the <code>google.golang.org/protobuf</code> implementation). Go is\n<a href=\"/blog/compat\">committed to backwards compatibility</a> and this\napplies to Go Protobuf, too!</p>\n<h2 id=\"background\">Background: the (existing) Open Struct API</h2>\n<p>We now call the existing API the Open Struct API, because generated struct types\nare open to direct access. In the next section, we will see how it differs from\nthe new Opaque API.</p>\n<p>To work with protocol buffers, you first create a <code>.proto</code> definition file like\nthis one:</p>\n<pre><code>edition = &quot;2023&quot;;  // successor to proto2 and proto3\n\npackage log;\n\nmessage LogEntry {\n  string backend_server = 1;\n  uint32 request_size = 2;\n  string ip_address = 3;\n}\n</code></pre>\n<p>Then, you <a href=\"https://protobuf.dev/getting-started/gotutorial/\" rel=\"noreferrer\" target=\"_blank\">run the protocol compiler\n(<code>protoc</code>)</a> to generate code\nlike the following (in a <code>.pb.go</code> file):</p>\n<pre><code>package logpb\n\ntype LogEntry struct {\n  BackendServer *string\n  RequestSize   *uint32\n  IPAddress     *string\n  // …internal fields elided…\n}\n\nfunc (l *LogEntry) GetBackendServer() string { … }\nfunc (l *LogEntry) GetRequestSize() uint32   { … }\nfunc (l *LogEntry) GetIPAddress() string     { … }\n</code></pre>\n<p>Now you can import the generated <code>logpb</code> package from your Go code and call\nfunctions like\n<a href=\"https://pkg.go.dev/google.golang.org/protobuf/proto#Marshal\" rel=\"noreferrer\" target=\"_blank\"><code>proto.Marshal</code></a>\nto encode <code>logpb.LogEntry</code> messages into protobuf wire format.</p>\n<p>You can find more details in the <a href=\"https://protobuf.dev/reference/go/go-generated/\" rel=\"noreferrer\" target=\"_blank\">Generated Code API\ndocumentation</a>.</p>\n<h3 id=\"presence\">(Existing) Open Struct API: Field Presence</h3>\n<p>An important aspect of this generated code is how <em>field presence</em> (whether a\nfield is set or not) is modeled. For instance, the above example models presence\nusing pointers, so you could set the <code>BackendServer</code> field to:</p>\n<ol>\n<li><code>proto.String(&quot;zrh01.prod&quot;)</code>: the field is set and contains &ldquo;zrh01.prod&rdquo;</li>\n<li><code>proto.String(&quot;&quot;)</code>: the field is set (non-<code>nil</code> pointer) but contains an\nempty value</li>\n<li><code>nil</code> pointer: the field is not set</li>\n</ol>\n<p>If you are used to generated code not having pointers, you are probably using\n<code>.proto</code> files that start with <code>syntax = &quot;proto3&quot;</code>. The field presence behavior\nchanged over the years:</p>\n<ul>\n<li><code>syntax = &quot;proto2&quot;</code> uses <em>explicit presence</em> by default</li>\n<li><code>syntax = &quot;proto3&quot;</code> used <em>implicit presence</em> by default (where cases 2 and 3\ncannot be distinguished and are both represented by an empty string), but was\nlater extended to allow <a href=\"https://protobuf.dev/programming-guides/proto3/#field-labels\" rel=\"noreferrer\" target=\"_blank\">opting into explicit presence with the <code>optional</code>\nkeyword</a></li>\n<li><code>edition = &quot;2023&quot;</code>, the <a href=\"https://protobuf.dev/editions/overview/\" rel=\"noreferrer\" target=\"_blank\">successor to both proto2 and\nproto3</a>, uses <a href=\"https://protobuf.dev/programming-guides/field_presence/\" rel=\"noreferrer\" target=\"_blank\"><em>explicit\npresence</em></a> by default</li>\n</ul>\n<h2 id=\"opaqueapi\">The new Opaque API</h2>\n<p>We created the new <em>Opaque API</em> to uncouple the <a href=\"https://protobuf.dev/reference/go/go-generated/\" rel=\"noreferrer\" target=\"_blank\">Generated Code\nAPI</a> from the underlying\nin-memory representation. The (existing) Open Struct API has no such separation:\nit allows programs direct access to the protobuf message memory. For example,\none could use the <code>flag</code> package to parse command-line flag values into protobuf\nmessage fields:</p>\n<pre><code>var req logpb.LogEntry\nflag.StringVar(&amp;req.BackendServer, &quot;backend&quot;, os.Getenv(&quot;HOST&quot;), &quot;…&quot;)\nflag.Parse() // fills the BackendServer field from -backend flag\n</code></pre>\n<p>The problem with such a tight coupling is that we can never change how we lay\nout protobuf messages in memory. Lifting this restriction enables many\nimplementation improvements, which we&rsquo;ll see below.</p>\n<p>What changes with the new Opaque API? Here is how the generated code from the\nabove example would change:</p>\n<pre><code>package logpb\n\ntype LogEntry struct {\n  xxx_hidden_BackendServer *string // no longer exported\n  xxx_hidden_RequestSize   uint32  // no longer exported\n  xxx_hidden_IPAddress     *string // no longer exported\n  // …internal fields elided…\n}\n\nfunc (l *LogEntry) GetBackendServer() string { … }\nfunc (l *LogEntry) HasBackendServer() bool   { … }\nfunc (l *LogEntry) SetBackendServer(string)  { … }\nfunc (l *LogEntry) ClearBackendServer()      { … }\n// …\n</code></pre>\n<p>With the Opaque API, the struct fields are hidden and can no longer be\ndirectly accessed. Instead, the new accessor methods allow for getting, setting,\nor clearing a field.</p>\n<h3 id=\"lessmemory\">Opaque structs use less memory</h3>\n<p>One change we made to the memory layout is to model field presence for\nelementary fields more efficiently:</p>\n<ul>\n<li>The (existing) Open Struct API uses pointers, which adds a 64-bit word to the\nspace cost of the field.</li>\n<li>The Opaque API uses <a href=\"https://en.wikipedia.org/wiki/Bit_field\" rel=\"noreferrer\" target=\"_blank\">bit\nfields</a>, which require one bit per\nfield (ignoring padding overhead).</li>\n</ul>\n<p>Using fewer variables and pointers also lowers load on the allocator and on the\ngarbage collector.</p>\n<p>The performance improvement depends heavily on the shapes of your protocol\nmessages: The change only affects elementary fields like integers, bools, enums,\nand floats, but not strings, repeated fields, or submessages (because it is\n<a href=\"https://protobuf.dev/reference/go/opaque-faq/#memorylayout\" rel=\"noreferrer\" target=\"_blank\">less\nprofitable</a>\nfor those types).</p>\n<p>Our benchmark results show that messages with few elementary fields exhibit\nperformance that is as good as before, whereas messages with more elementary\nfields are decoded with significantly fewer allocations:</p>\n<pre><code>             │ Open Struct API │             Opaque API             │\n             │    allocs/op    │  allocs/op   vs base               │\nProd#1          360.3k ± 0%       360.3k ± 0%  +0.00% (p=0.002 n=6)\nSearch#1       1413.7k ± 0%       762.3k ± 0%  -46.08% (p=0.002 n=6)\nSearch#2        314.8k ± 0%       132.4k ± 0%  -57.95% (p=0.002 n=6)\n</code></pre>\n<p>Reducing allocations also makes decoding protobuf messages more efficient:</p>\n<pre><code>             │ Open Struct API │             Opaque API            │\n             │   user-sec/op   │ user-sec/op  vs base              │\nProd#1         55.55m ± 6%        55.28m ± 4%  ~ (p=0.180 n=6)\nSearch#1       324.3m ± 22%       292.0m ± 6%  -9.97% (p=0.015 n=6)\nSearch#2       67.53m ± 10%       45.04m ± 8%  -33.29% (p=0.002 n=6)\n</code></pre>\n<p>(All measurements done on an AMD Castle Peak Zen 2. Results on ARM and Intel\nCPUs are similar.)</p>\n<p>Note: proto3 with implicit presence similarly does not use pointers, so you will\nnot see a performance improvement if you are coming from proto3. If you were\nusing implicit presence for performance reasons, forgoing the convenience of\nbeing able to distinguish empty fields from unset ones, then the Opaque API now\nmakes it possible to use explicit presence without a performance penalty.</p>\n<h3 id=\"lazydecoding\">Motivation: Lazy Decoding</h3>\n<p>Lazy decoding is a performance optimization where the contents of a submessage\nare decoded when first accessed instead of during\n<a href=\"https://pkg.go.dev/google.golang.org/protobuf/proto#Unmarshal\" rel=\"noreferrer\" target=\"_blank\"><code>proto.Unmarshal</code></a>. Lazy\ndecoding can improve performance by avoiding unnecessarily decoding fields which\nare never accessed.</p>\n<p>Lazy decoding can&rsquo;t be supported safely by the (existing) Open Struct API. While\nthe Open Struct API provides getters, leaving the (un-decoded) struct fields\nexposed would be extremely error-prone. To ensure that the decoding logic runs\nimmediately before the field is first accessed, we must make the field private\nand mediate all accesses to it through getter and setter functions.</p>\n<p>This approach made it possible to implement lazy decoding with the Opaque\nAPI. Of course, not every workload will benefit from this optimization, but for\nthose that do benefit, the results can be spectacular: We have seen logs\nanalysis pipelines that discard messages based on a top-level message condition\n(e.g. whether <code>backend_server</code> is one of the machines running a new Linux kernel\nversion) and can skip decoding deeply nested subtrees of messages.</p>\n<p>As an example, here are the results of the micro-benchmark we included,\ndemonstrating how lazy decoding saves over 50% of the work and over 87% of\nallocations!</p>\n<pre><code>                  │   nolazy    │                lazy                │\n                  │   sec/op    │   sec/op     vs base               │\nUnmarshal/lazy-24   6.742µ ± 0%   2.816µ ± 0%  -58.23% (p=0.002 n=6)\n\n                  │    nolazy    │                lazy                 │\n                  │     B/op     │     B/op      vs base               │\nUnmarshal/lazy-24   3.666Ki ± 0%   1.814Ki ± 0%  -50.51% (p=0.002 n=6)\n\n                  │   nolazy    │               lazy                │\n                  │  allocs/op  │ allocs/op   vs base               │\nUnmarshal/lazy-24   64.000 ± 0%   8.000 ± 0%  -87.50% (p=0.002 n=6)\n</code></pre>\n<h3 id=\"pointercomparison\">Motivation: reduce pointer comparison mistakes</h3>\n<p>Modeling field presence with pointers invites pointer-related bugs.</p>\n<p>Consider an enum, declared within the <code>LogEntry</code> message:</p>\n<pre><code>message LogEntry {\n  enum DeviceType {\n    DESKTOP = 0;\n    MOBILE = 1;\n    VR = 2;\n  };\n  DeviceType device_type = 1;\n}\n</code></pre>\n<p>A simple mistake is to compare the <code>device_type</code> enum field like so:</p>\n<pre><code>if cv.DeviceType == logpb.LogEntry_DESKTOP.Enum() { // incorrect!\n</code></pre>\n<p>Did you spot the bug? The condition compares the memory address instead of the\nvalue. Because the <code>Enum()</code> accessor allocates a new variable on each call, the\ncondition can never be true. The check should have read:</p>\n<pre><code>if cv.GetDeviceType() == logpb.LogEntry_DESKTOP {\n</code></pre>\n<p>The new Opaque API prevents this mistake: Because fields are hidden, all access\nmust go through the getter.</p>\n<h3 id=\"accidentalsharing\">Motivation: reduce accidental sharing mistakes</h3>\n<p>Let&rsquo;s consider a slightly more involved pointer-related bug. Assume you are\ntrying to stabilize an RPC service that fails under high load. The following\npart of the request middleware looks correct, but still the entire service goes\ndown whenever just one customer sends a high volume of requests:</p>\n<pre><code>logEntry.IPAddress = req.IPAddress\nlogEntry.BackendServer = proto.String(hostname)\n// The redactIP() function redacts IPAddress to 127.0.0.1,\n// unexpectedly not just in logEntry *but also* in req!\ngo auditlog(redactIP(logEntry))\nif quotaExceeded(req) {\n    // BUG: All requests end up here, regardless of their source.\n    return fmt.Errorf(&quot;server overloaded&quot;)\n}\n</code></pre>\n<p>Did you spot the bug? The first line accidentally copied the pointer (thereby\nsharing the pointed-to variable between the <code>logEntry</code> and <code>req</code> messages)\ninstead of its value. It should have read:</p>\n<pre><code>logEntry.IPAddress = proto.String(req.GetIPAddress())\n</code></pre>\n<p>The new Opaque API prevents this problem as the setter takes a value\n(<code>string</code>) instead of a pointer:</p>\n<pre><code>logEntry.SetIPAddress(req.GetIPAddress())\n</code></pre>\n<h3 id=\"reflection\">Motivation: Fix Sharp Edges: reflection</h3>\n<p>To write code that works not only with a specific message type\n(e.g. <code>logpb.LogEntry</code>), but with any message type, one needs some kind of\nreflection. The previous example used a function to redact IP addresses. To work\nwith any type of message, it could have been defined as <code>func redactIP(proto.Message) proto.Message { … }</code>.</p>\n<p>Many years ago, your only option to implement a function like <code>redactIP</code> was to\nreach for <a href=\"/blog/laws-of-reflection\">Go&rsquo;s <code>reflect</code> package</a>,\nwhich resulted in very tight coupling: you had only the generator output and had\nto reverse-engineer what the input protobuf message definition might have looked\nlike. The <a href=\"/blog/protobuf-apiv2\"><code>google.golang.org/protobuf</code> module\nrelease</a> (from March 2020) introduced\n<a href=\"https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect\" rel=\"noreferrer\" target=\"_blank\">Protobuf\nreflection</a>,\nwhich should always be preferred: Go&rsquo;s <code>reflect</code> package traverses the data\nstructure&rsquo;s representation, which should be an implementation detail. Protobuf\nreflection traverses the logical tree of protocol messages without regard to its\nrepresentation.</p>\n<p>Unfortunately, merely <em>providing</em> protobuf reflection is not sufficient and\nstill leaves some sharp edges exposed: In some cases, users might accidentally\nuse Go reflection instead of protobuf reflection.</p>\n<p>For example, encoding a protobuf message with the <code>encoding/json</code> package (which\nuses Go reflection) was technically possible, but the result is not <a href=\"https://protobuf.dev/programming-guides/proto3/#json\" rel=\"noreferrer\" target=\"_blank\">canonical\nProtobuf JSON\nencoding</a>. Use the\n<a href=\"https://pkg.go.dev/google.golang.org/protobuf/encoding/protojson\" rel=\"noreferrer\" target=\"_blank\"><code>protojson</code></a>\npackage instead.</p>\n<p>The new Opaque API prevents this problem because the message struct fields are\nhidden: accidental usage of Go reflection will see an empty message. This is\nclear enough to steer developers towards protobuf reflection.</p>\n<h3 id=\"idealmemory\">Motivation: Making the ideal memory layout possible</h3>\n<p>The benchmark results from the <a href=\"#lessmemory\">More Efficient Memory\nRepresentation</a> section have already shown that protobuf\nperformance heavily depends on the specific usage: How are the messages defined?\nWhich fields are set?</p>\n<p>To keep Go Protobuf as fast as possible for <em>everyone</em>, we cannot implement\noptimizations that help only one program, but hurt the performance of other\nprograms.</p>\n<p>The Go compiler used to be in a similar situation, up until <a href=\"/blog/go1.20\">Go 1.20 introduced\nProfile-Guided Optimization (PGO)</a>. By recording the\nproduction behavior (through <a href=\"/blog/pprof\">profiling</a>) and feeding\nthat profile back to the compiler, we allow the compiler to make better\ntrade-offs <em>for a specific program or workload</em>.</p>\n<p>We think using profiles to optimize for specific workloads is a promising\napproach for further Go Protobuf optimizations. The Opaque API makes those\npossible: Program code uses accessors and does not need to be updated when the\nmemory representation changes, so we could, for example, move rarely set fields\ninto an overflow struct.</p>\n<h2 id=\"migration\">Migration</h2>\n<p>You can migrate on your own schedule, or even not at all—the (existing) Open\nStruct API will not be removed. But, if you’re not on the new Opaque API, you\nwon’t benefit from its improved performance, or future optimizations that target\nit.</p>\n<p>We recommend you select the Opaque API for new development. Protobuf Edition\n2024 (see <a href=\"https://protobuf.dev/editions/overview/\" rel=\"noreferrer\" target=\"_blank\">Protobuf Editions Overview</a>\nif you are not yet familiar) will make the Opaque API the default.</p>\n<h3 id=\"hybridapi\">The Hybrid API</h3>\n<p>Aside from the Open Struct API and Opaque API, there is also the Hybrid API,\nwhich keeps existing code working by keeping struct fields exported, but also\nenabling migration to the Opaque API by adding the new accessor methods.</p>\n<p>With the Hybrid API, the protobuf compiler will generate code on two API levels:\nthe <code>.pb.go</code> is on the Hybrid API, whereas the <code>_protoopaque.pb.go</code> version is\non the Opaque API and can be selected by building with the <code>protoopaque</code> build\ntag.</p>\n<h3 id=\"rewriting\">Rewriting Code to the Opaque API</h3>\n<p>See the <a href=\"https://protobuf.dev/reference/go/opaque-migration/\" rel=\"noreferrer\" target=\"_blank\">migration\nguide</a>\nfor detailed instructions. The high-level steps are:</p>\n<ol>\n<li>Enable the Hybrid API.</li>\n<li>Update existing code using the <code>open2opaque</code> migration tool.</li>\n<li>Switch to the Opaque API.</li>\n</ol>\n<h3 id=\"publishing\">Advice for published generated code: Use Hybrid API</h3>\n<p>Small usages of protobuf can live entirely within the same repository, but\nusually, <code>.proto</code> files are shared between different projects that are owned by\ndifferent teams. An obvious example is when different companies are involved: To\ncall Google APIs (with protobuf), use the <a href=\"https://github.com/googleapis/google-cloud-go\" rel=\"noreferrer\" target=\"_blank\">Google Cloud Client Libraries for\nGo</a> from your project. Switching\nthe Cloud Client Libraries to the Opaque API is not an option, as that would be\na breaking API change, but switching to the Hybrid API is safe.</p>\n<p>Our advice for such packages that publish generated code (<code>.pb.go</code> files) is to\nswitch to the Hybrid API please! Publish both the <code>.pb.go</code> and the\n<code>_protoopaque.pb.go</code> files, please. The <code>protoopaque</code> version allows your\nconsumers to migrate on their own schedule.</p>\n<h3 id=\"enablelazy\">Enabling Lazy Decoding</h3>\n<p>Lazy decoding is available (but not enabled) once you migrate to the Opaque API!\n🎉</p>\n<p>To enable: in your <code>.proto</code> file, annotate your message-typed fields with the\n<code>[lazy = true]</code> annotation.</p>\n<p>To opt out of lazy decoding (despite <code>.proto</code> annotations), the <a href=\"https://pkg.go.dev/google.golang.org/protobuf/runtime/protolazy\" rel=\"noreferrer\" target=\"_blank\"><code>protolazy</code>\npackage\ndocumentation</a>\ndescribes the available opt-outs, which affect either an individual Unmarshal\noperation or the entire program.</p>\n<h2 id=\"nextsteps\">Next Steps</h2>\n<p>By using the open2opaque tool in an automated fashion over the last few years,\nwe have converted the vast majority of Google’s <code>.proto</code> files and Go code to\nthe Opaque API. We continuously improved the Opaque API implementation as we\nmoved more and more production workloads to it.</p>\n<p>Therefore, we expect you should not encounter problems when trying the Opaque\nAPI. In case you do encounter any issues after all, please <a href=\"https://github.com/golang/protobuf/issues/\" rel=\"noreferrer\" target=\"_blank\">let us know on the\nGo Protobuf issue tracker</a>.</p>\n<p>Reference documentation for Go Protobuf can be found on <a href=\"https://protobuf.dev/reference/go/\" rel=\"noreferrer\" target=\"_blank\">protobuf.dev → Go\nReference</a>.</p>\n\n    </div>\n\n    \n    <div class=\"Article prevnext\">\n    \n    \n      \n    \n      \n        <p>\n        \n          \n            <b>Next article: </b><a href=\"/blog/survey2024-h2-results\">Go Developer Survey 2024 H2 Results</a><br>\n          \n        \n        \n          \n            <b>Previous article: </b><a href=\"/blog/15years\">Go Turns 15</a><br>\n          \n        \n        <b><a href=\"/blog/all\">Blog Index</a></b>\n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n      \n    \n    </div>\n    \n\n  </div>\n</div>\n\n<script src=\"/js/play.js\"></script>\n\n","flags":null,"enclosureUrl":"","enclosureMime":""}]}