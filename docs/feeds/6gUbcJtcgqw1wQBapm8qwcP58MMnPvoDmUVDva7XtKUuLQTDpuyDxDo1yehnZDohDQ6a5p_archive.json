{"id":"6gUbcJtcgqw1wQBapm8qwcP58MMnPvoDmUVDva7XtKUuLQTDpuyDxDo1yehnZDohDQ6a5p","title":"Slashdot: Developers","displayTitle":"Dev - Slashdot - Dev","url":"http://rss.slashdot.org/Slashdot/slashdotDevelopers","feedLink":"https://developers.slashdot.org/","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":15,"items":[{"title":"Can TrapC Fix C and C++ Memory Safety Issues?","url":"https://developers.slashdot.org/story/25/03/03/0654205/can-trapc-fix-c-and-c-memory-safety-issues?utm_source=rss1.0mainlinkanon&utm_medium=feed","date":1740990840,"author":"EditorDavid","guid":227,"unread":true,"content":"\"TrapC, a fork of the C language, is being developed as a potential solution for memory safety issues that have hindered the C and C++ languages,\" reports InfoWorld. \nBut also being developed is a compiler named trapc \"intended to be implemented as a cybersecurity compiler for C and C++ code, said developer Robin Rowe...\"\n\n Due by the end of this year, trapc will be a free, open source compiler similar to Clang... Rowe said. TrapC has pointers that are memory-safe, addressing the memory safety issue with the two languages. With TrapC, developers write in C or C++ and compile in TrapC, for memory safety... \nRowe presented TrapC at an ISO C meeting this week. Developers can download a TrapC whitepaper and offer Rowe feedback. According to the whitepaper, TrapC's memory management is automatic and cannot leak memory. Pointers are lifetime-managed, not garbage-collected. Also, TrapC reuses a few code safety features from C++, notably member functions, constructors, destructors, and the new keyword. \n\n\"TrapC Memory Safe Pointers will not buffer overrun and will not segfault,\" Rowe told the ISO C Committee standards body meeting, according to the Register. \"When C code is compiled using a TrapC compiler, all pointers become Memory Safe Pointers and are checked.\"\n \nIn short, TrapC \"is a programming language forked from C, with changes to make it LangSec and Memory Safe,\" according to that white paper. \"To accomplish that, TrapC seeks to eliminate all Undefined Behavior in the C programming language...\" \n\n\"The startup TRASEC and the non-profit Fountain Abode have a TrapC compiler in development, called trapc,\" the whitepaper adds, and their mission is \"to enable recompiling legacy C code into executables that are safe by design and secure by default, without needing much code refactoring... The TRASEC trapc cybersecurity compiler with AI code reasoning is expected to release as free open source software sometime in 2025.\" \n\nIn November the Register offered some background on the origins of TrapC...\n","contentLength":2026,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Malicious PyPI Package Exploited Deezer's API, Orchestrates a Distributed Piracy Operation","url":"https://yro.slashdot.org/story/25/03/02/064255/malicious-pypi-package-exploited-deezers-api-orchestrates-a-distributed-piracy-operation?utm_source=rss1.0mainlinkanon&utm_medium=feed","date":1740914400,"author":"EditorDavid","guid":226,"unread":true,"content":"A malicious PyPi package effectively turned its users' systems \"into an illicit network for facilitating bulk music downloads,\" writes The Hacker News. \n\nThough the package has been removed from PyPI, researchers at security platform Socket.dev say it enabled \"coordinated, unauthorized music downloads from Deezer — a popular streaming service founded in France in 2007.\"\n\nAlthough automslc, which has been downloaded over 100,000 times, purports to offer music automation and metadata retrieval, it covertly bypasses Deezer's access restrictions... The package is designed to log into Deezer, harvest track metadata, request full-length streaming URLs, and download complete audio files in clear violation of Deezer's API terms... [I]t orchestrates a distributed piracy operation by leveraging both user-supplied and hardcoded Deezer credentials to create sessions with Deezer's API. This approach enables full access to track metadata and the decryption tokens required to generate full-length track URLs. \n\nAdditionally, the package routinely communicates with a remote server... to update download statuses and submit metadata, thereby centralizing control and allowing the threat actor to monitor and coordinate the distributed downloading operation. In doing so, automslc exposes critical track details — including Deezer IDs, International Standard Recording Codes, track titles, and internal tokens like MD5_ORIGIN (a hash used in generating decryption URLs) — which, when collected en masse, can be used to reassemble full track URLs and facilitate unauthorized downloads... \n\nEven if a user pays for access to the service, the content is licensed, not owned. The automslc package circumvents licensing restrictions by enabling downloads and potential redistribution, which is outside the bounds of fair use... \n\"The malicious package was initially published in 2019, and its popularity (over 100,000 downloads) indicates wide distribution...\"","contentLength":1959,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"27-Year-Old EXE Became Python In Minutes. Is AI-Assisted Reverse Engineering Next?","url":"https://developers.slashdot.org/story/25/03/01/2211210/27-year-old-exe-became-python-in-minutes-is-ai-assisted-reverse-engineering-next?utm_source=rss1.0mainlinkanon&utm_medium=feed","date":1740890040,"author":"EditorDavid","guid":225,"unread":true,"content":"Adafruit managing director Phillip Torrone (also long-time Slashdot reader ptorrone) shared an interesting blog post. They'd spotted a Reddit post \"detailing how someone took a 27-year-old visual basic EXE file, fed it to Claude 3.7, and watched as it reverse-engineered the program and rewrote it in Python.\"\n\nIt was an old Visual Basic 4 program they had written in 1997. Running a VB4 exe in 2024 can be a real yak-shaving compatibility nightmare, chasing down outdated DLLs and messy workarounds. So! OP decided to upload the exe to Claude 3.7 with this request: \n\"Can you tell me how to get this file running? It'd be nice to convert it to Python.\"&gt; \nClaude 3.7 analyzed the binary, extracted the VB 'tokens' (VB is not a fully-machine-code-compiled language which makes this task a lot easier than something from C/C++), identified UI elements, and even extracted sound files. Then, it generated a complete Python equivalent using Pygame. According to the author, the code worked on the first try and the entire process took less than five minutes... \nTorrone speculates on what this might mean. \"Old business applications and games could be modernized without needing the original source code... Tools like Claude might make decompilation and software archaeology a lot easier: proprietary binaries from dead platforms could get a new life in open-source too.\" \n\nAnd maybe Archive.org could even add an LLM \"to do this on the fly!\"","contentLength":1438,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Perl's CPAN Security Group is Now a CNA, Can Assign CVEs","url":"https://developers.slashdot.org/story/25/03/01/0548217/perls-cpan-security-group-is-now-a-cna-can-assign-cves?utm_source=rss1.0mainlinkanon&utm_medium=feed","date":1740857640,"author":"EditorDavid","guid":224,"unread":true,"content":"Active since 1995, the Comprehensive Perl Archive Network (or CPAN) hosts 221,742 Perl modules written by 14,548 authors. This week they announced that the CPAN Security Group \"was authorized by the CVE Program as a CVE Numbering Authority (CNA)\" to assign and manage CVE vulnerability identifications for Perl and CPAN Modules. \n\n\"This is great news!\" posted Linux kernel maintainer Greg Kroah-Hartman on social media, saying the announcement came \"Just in time for my talk about this very topic in a few weeks about how all open source projects should be doing this\" at the Linux Foundation Member Summit in Napa, California. And Curl creator Daniel Stenberg posted \"I'm with Greg Kroah-Hartman on this: all Open Source projects should become CNAs. Or team up with others to do it.\" (Also posting \"Agreed\" to the suggestion was Seth Larson, the Python Software Foundation's security developer-in-residence involved in their successful effort to become a CNA in 2023.) \n\n444 CNAs have now partnered with the CVE Program, according to their official web site. The announcement from PerlMonks.org:\n\nYears ago, a few people decided during the Perl Toolchain Summit (PTS) that it would be a good idea to join forces, ideas and knowledge and start a group to monitor vulnerabilities in the complete Perl ecosystem from core to the smallest CPAN release. The goal was to follow legislation and CVE reports, and help authors in taking actions on not being vulnerable anymore. That group has grown stable over the past years and is now known as CPANSec. \n\nThe group has several focus areas, and one of them is channeling CVE vulnerability issues. In that specific goal, a milestone has been reached: CPANSec has just been authorized as a CVE Numbering Authority (CNA) for Perl and modules on CPAN\n","contentLength":1790,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Google Calls for Measurable Memory-Safety Standards for Software","url":"https://developers.slashdot.org/story/25/02/28/0340214/google-calls-for-measurable-memory-safety-standards-for-software?utm_source=rss1.0mainlinkanon&utm_medium=feed","date":1740843240,"author":"EditorDavid","guid":223,"unread":true,"content":"Memory safety bugs are \"eroding trust in technology and costing billions,\" argues a new post on Google's security blog — adding that \"traditional approaches, like code auditing, fuzzing, and exploit mitigations — while helpful — haven't been enough to stem the tide.\" \n\nSo the blog post calls for a \"common framework\" for \"defining specific, measurable criteria for achieving different levels of memory safety assurance.\" The hope is this gives policy makers \"the technical foundation to craft effective policy initiatives and incentives promoting memory safety\" leading to \"a market in which vendors are incentivized to invest in memory safety.\" (\"Customers will be empowered to recognize, demand, and reward safety.\") \n\nIn January the same Google security researchers helped co-write an article noting there are now strong memory-safety \"research technologies\" that are sufficiently mature: memory-safe languages (including \"safer language subsets like Safe Buffers for C++\"), mathematically rigorous formal verification, software compartmentalization, and hardware and software protections. (With hardware protections including things like ARM's Memory Tagging Extension and the (Capability Hardware Enhanced RISC Instructions, or \"CHERI\", architecture.) Google's security researchers are now calling for \"a blueprint for a memory-safe future\" — though Importantly, the idea is \"defining the desired outcomes rather than locking ourselves into specific technologies.\" \n\nTheir blog post this week again urges a practical/actionable framework that's commonly understood, but one that supports different approaches (and allowing tailoring to specific needs) while enabling objective assessment:\n\nAt Google, we're not just advocating for standardization and a memory-safe future, we're actively working to build it. We are collaborating with industry and academic partners to develop potential standards, and our joint authorship of the recent CACM call-to-action marks an important first step in this process... This commitment is also reflected in our internal efforts. We are prioritizing memory-safe languages, and have already seen significant reductions in vulnerabilities by adopting languages like Rust in combination with existing, wide-spread usage of Java, Kotlin, and Go where performance constraints permit. We recognize that a complete transition to those languages will take time. That's why we're also investing in techniques to improve the safety of our existing C++ codebase by design, such as deploying hardened libc++. \n\nThis effort isn't about picking winners or dictating solutions. It's about creating a level playing field, empowering informed decision-making, and driving a virtuous cycle of security improvement... The journey towards memory safety requires a collective commitment to standardization. We need to build a future where memory safety is not an afterthought but a foundational principle, a future where the next generation inherits a digital world that is secure by design. \nThe security researchers' post calls for \"a collective commitment\" to eliminate memory-safety bugs, \"anchored on secure-by-design practices...\" One of the blog post's subheadings? \"Let's build a memory-safe future together.\" \n\nAnd they're urging changes \"not just for ourselves but for the generations that follow.\"","contentLength":3336,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"The Reality of Long-Term Software Maintenance","url":"https://developers.slashdot.org/story/25/02/27/0931201/the-reality-of-long-term-software-maintenance?utm_source=rss1.0mainlinkanon&utm_medium=feed","date":1740679200,"author":"msmash","guid":222,"unread":true,"content":"When developers boast \"I could write that in a weekend,\" they're missing the painful reality that haunts software maintainers for years. In a candid blog post, Construct developer Ashley explains why maintaining large software projects is a burden most programmers fail to appreciate. \"Writing the initial code for a feature is only a fraction of the work,\" Ashley explains, estimating it represents just \"25% of the total work\" in Construct's 750,000-line codebase. The rest? A grinding cycle of \"testing, diagnosing and fixing bugs, optimizing performance, upgrading it to work with other changes, refactoring, customer support, writing documentation and similarly revising the documentation over time.\" \n\nAshley describes how accepting code contributions feels like someone offering to build you a free extension -- initially attractive until the roof starts leaking years later and the original builder is nowhere to be found. Meanwhile, your tenants (users) are furious, and you're stuck with \"no good options.\" The post recounts Construct's own bruises: a community-contributed storage plugin still causing compatibility headaches a decade later, and third-party libraries that became maintenance nightmares after their creators vanished. \n\nThese experiences explain why seasoned maintainers eye large code contributions with deep suspicion rather than gratitude. \"If you suggest some software project uses some code -- even a small amount -- will you be there in literally 10 year's time sorting out all the issues that arise from it?\" Ashley asks. \"Usually the answer is no.\"","contentLength":1583,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"ExpressVPN Gets Faster and More Secure, Thanks To Rust","url":"https://developers.slashdot.org/story/25/02/26/2133246/expressvpn-gets-faster-and-more-secure-thanks-to-rust?utm_source=rss1.0mainlinkanon&utm_medium=feed","date":1740606000,"author":"BeauHD","guid":221,"unread":true,"content":"ZDNet's Steven Vaughan-Nichols shares some of the latest improvements to ExpressVPN following its codebase transition from C to Rust. An anonymous reader quotes an excerpt from the report: ExpressVPN is one of ZDNET's favorite Virtual Private Networks (VPNs). The popular VPN's transformation of its Lightway codebase from C to Rust promises to make the service faster and more secure. For now, the updated Lightway 2.0 is only available via ExpressVPN's Aircove router with the February 4 AircoveOS v5 update. The Aircove, which we rate as the best VPN router, costs $189. With this device, you can protect your tech from unwanted snoopers without installing a VPN on each gadget. So, how much faster is the updated ExpressVPN? In my tests, I connected to the internet via my updated router over my 2 Gigabit per second (Gbps) AT&amp;T Internet using a 2.5 Gbps Ethernet-connected Linux Mint desktop with a Wi-Fi 6 connection over my Samsung Galaxy 25 Plus smartphone.\n \nWithout the VPN engaged, I saw 1.6 Gbps speeds, which is about par. With the VPN switched on and using Lightway 2.0, I saw speeds in the 290 to 330 Megabit per second (Mbps) range to Toronto and London, England. Farther afield, I saw speeds around 250 to 280Mbps to Hong Kong and Seoul. That's about 20% faster than I had seen with earlier Lightway versions. I was impressed. This version of the VPN should also be more secure. As Pete Membrey, ExpressVPN's chief research officer, said in a statement: \"At ExpressVPN, we innovate to solve the challenges of tomorrow. Upgrading Lightway from its previous C code to Rust was a strategic and straightforward decision to enhance performance and security while ensuring longevity.\"\n \nThe updated Lightway VPN protocol also uses ML-KEM, the newly finalized NIST standard for post-quantum encryption. This feature, wrote Membray in a blog post, \"ensures your connection is secured by encryption designed not just for today's threats but for the quantum-powered challenges of the future.\" To ensure the integrity of the recoded Lightway protocol, ExpressVPN commissioned two independent security audits from cybersecurity firms Cure53 and Praetorian. Both audits yielded positive results, with only minor vulnerabilities identified and promptly addressed by ExpressVPN. In short, ExpressVPN is technically about as safe a VPN as they come.","contentLength":2350,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Google Makes Gemini Code Assist Free","url":"https://tech.slashdot.org/story/25/02/25/1640216/google-makes-gemini-code-assist-free?utm_source=rss1.0mainlinkanon&utm_medium=feed","date":1740501900,"author":"msmash","guid":220,"unread":true,"content":"Google has launched a free version of Gemini Code Assist, offering developers substantially higher usage limits than competing services. From a report: The AI coding assistant, powered by the fine-tuned Gemini 2.0 model, allows up to 180,000 code completions monthly -- 90 times more than GitHub Copilot's free tier limit of 2,000. The release comes just one day after Anthropic introduced Claude Code, underscoring intensifying competition in AI-powered development tools. \n\nGemini Code Assist integrates with popular environments including Visual Studio Code, JetBrains IDEs, and GitHub, where it performs code reviews on both public and private repositories. Google's offering features a 128,000-token context window, enabling developers to work with larger codebases. The service supports all public domain programming languages and requires only a Gmail account to register, with no credit card needed. \n\nAccording to Ryan Salva, Google Cloud's senior director of product management, more than 75% of developers now rely on AI in their daily work, with over 25% of new code at Google being AI-generated. For developers wanting advanced features like private repository integration or Google Cloud service connections, premium tiers remain available.","contentLength":1254,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Anthropic Launches the World's First 'Hybrid Reasoning' AI Model","url":"https://developers.slashdot.org/story/25/02/24/213202/anthropic-launches-the-worlds-first-hybrid-reasoning-ai-model?utm_source=rss1.0mainlinkanon&utm_medium=feed","date":1740433200,"author":"BeauHD","guid":219,"unread":true,"content":"An anonymous reader quotes a report from Wired: Anthropic, an artificial intelligence company founded by exiles from OpenAI, has introduced the first AI model that can produce either conventional output or a controllable amount of \"reasoning\" needed to solve more grueling problems. Anthropic says the new hybrid model, called Claude 3.7, will make it easier for users and developers to tackle problems that require a mix of instinctive output and step-by-step cogitation. \"The [user] has a lot of control over the behavior -- how long it thinks, and can trade reasoning and intelligence with time and budget,\" says Michael Gerstenhaber, product lead, AI platform at Anthropic.\n \nClaude 3.7 also features a new \"scratchpad\" that reveals the model's reasoning process. A similar feature proved popular with theChinese AI model DeepSeek. It can help a user understand how a model is working over a problem in order to modify or refine prompts. Dianne Penn, product lead of research at Anthropic, says the scratchpad is even more helpful when combined with the ability to ratchet a model's \"reasoning\" up and down. If, for example, the model struggles to break down a problem correctly, a user can ask it to spend more time working on it. [...]\n \nPenn says that Claude's reasoning mode received additional data on business applications including writing and fixing code, using computers, and answering complex legal questions. \"The things that we made improvements on are ... technical subjects or subjects which require long reasoning,\" Penn says. \"What we have from our customers is a lot of interest in deploying our models into their actual workloads.\" Anthropic says that Claude 3.7 is especially good at solving coding problems that require step-by-step reasoning, outscoring OpenAI's o1 on some benchmarks like SWE-bench. The company is today releasing a new tool, called Claude Code, specifically designed for this kind of AI-assisted coding. \"The model is already good at coding,\" Penn says. But \"additional thinking would be good for cases that might require very complex planning -- say you're looking at an extremely large code base for a company.\"","contentLength":2157,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Greg Kroah-Hartman Supports Rust in the Kernel","url":"https://linux.slashdot.org/story/25/02/22/0543255/greg-kroah-hartman-supports-rust-in-the-kernel?utm_source=rss1.0mainlinkanon&utm_medium=feed","date":1740332040,"author":"EditorDavid","guid":196,"unread":true,"content":"An anonymous Slashdot reader shared this report from Phoronix:\n\nLinux's second-in-command Greg Kroah-Hartman has also been a big proponent of Rust kernel code. He's crafted another Linux kernel mailing list post [Wednesdsay] outlining the benefits of Rust and encouraging new kernel code/drivers to be in Rust rather than C. Greg KH makes the case that the majority of the kernel bugs are due to \"stupid little corner cases in C that are totally gone in Rust.\" \n\n\"As someone who has seen almost EVERY kernel bugfix and security issue for the past 15+ years... and who sees EVERY kernel CVE issued, I think I can speak on this topic,\" Kroah-Hartman began. Here's some excerpts from his remarks. Citing corner cases like overwrites of memory, error path cleanups, use-after-free mistakes and forgetting to check error values, Kroah-Hartman says he's \"all for... making these types of problems impossible to hit.\"\n\nThat's why I'm wanting to see Rust get into the kernel, these types of issues just go away, allowing developers and maintainers more time to focus on the REAL bugs that happen (i.e. logic issues, race conditions, etc.)... [F]or new code / drivers, writing them in Rust where these types of\nbugs just can't happen (or happen much much less) is a win for all of\nus, why wouldn't we do this...? Rust isn't a \"silver bullet\" that will solve all of our problems, but it sure will help in a huge number of places, so for new stuff going forward, why wouldn't we want that...? \n\nYes, mixed language codebases are rough, and hard to maintain, but we are kernel developers dammit, we've been maintaining and strengthening Linux for longer than anyone ever thought was going to be possible. We've turned our development model into a well-oiled engineering marvel creating something that no one else has ever been able to accomplish. Adding another language really shouldn't be a problem, we've handled much worse things in the past and we shouldn't give up now on wanting to ensure that our project succeeds for the next 20+ years. We've got to keep pushing forward when confronted with new good ideas, and embrace the people offering to join us in actually doing the work to help make sure that we all succeed together. \n\nKroah-Hartman emphasized later that \"a huge majority of the stupid things we do in C just don't happen in the same code implemented in Rust (i.e. memory leaks, error path cleanups, return value checking, etc.) \" \n\nThe complete thread contains over 140 messages — including Linus Torvalds' observation that \" #pragma is complete garbage and should never be used.\"","contentLength":2589,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Rust Developer Survey Finds Increasing Usage, Especially on Linux","url":"https://developers.slashdot.org/story/25/02/22/042227/rust-developer-survey-finds-increasing-usage-especially-on-linux?utm_source=rss1.0mainlinkanon&utm_medium=feed","date":1740260040,"author":"EditorDavid","guid":218,"unread":true,"content":"This year's \"State of Rust\" survey was completed by 7,310 Rust developers. DevClass note some key findings:\n\nWhen asked about their biggest worries for Rust's future, 45.5 percent cited \"not enough usage in the tech industry,\" up from 42.5 percent last year, just ahead of the 45.2 percent who cited complexity as a concern... Only 18.6 percent declared themselves \"not worried,\" though this is a slight improvement on 17.8 percent in 2023... \nAnother question asks whether respondents are using Rust at work. 38.2 percent claimed to use it for most of their coding [up from 34% in 2023], and 13.4 percent a few times a week, accounting for just over half of responses. At the organization level there is a similar pattern. 45.5 percent of organizations represented by respondents make \"non-trivial use of Rust,\" up from 38.7 percent last year. \n\nMore details from I Programmer:\n\nOn the up are \"Using Rust helps us achieve or goals\", now 82% compared to 72% in 2022; \"We're likely to use Rust again in the future\", up 3% to 78%; and \"Using Rust has been worth the cost of Adoption\". Going down are \"Adopting Rust has been challenging\", now 34.5% compared to 38.5% in 2022; and \"Overall adopting Rust has slowed down our team\" down by over 2% to 7%. \n\n\n\n\"According to the survey, organizations primarily choose Rust for building correct and bug-free software (87.1%), performance characteristics (84.5%), security and safety properties (74.8%), and development enjoyment (71.2%),\" writes The New Stack:\n\n Rust seems to be especially popular for creating server backends (53.4%), web and networking services, cloud technologies and WebAssembly, the report said. It also seems to be gaining more traction for embedded use cases... Regarding the preferred development environment, Linux remains the dominant development platform (73.7%). \n\nHowever, although VS Code remains the leading editor, its usage dropped five percentage points, from 61.7% to 56.7%, but the Zed editor gained notable traction, from 0.7% to 8.9%. Also, \"nine out of 10 Rust developers use the current stable version, suggesting strong confidence in the language's stability,\" the report said... \n\nOverall, 82% of respondents report that Rust helped their company achieve its goals, and daily Rust usage increased to 53% (up four percentage points from 2023). When asked why they use Rust at work, 47% of respondents cited a need for precise control over their software, which is up from 37% when the question was asked two years ago.","contentLength":2502,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Torvalds: Rust Kernel Code Isn't Forced In Over Maintainers' Objections","url":"https://linux.slashdot.org/story/25/02/22/0524210/torvalds-rust-kernel-code-isnt-forced-in-over-maintainers-objections?utm_source=rss1.0mainlinkanon&utm_medium=feed","date":1740239640,"author":"EditorDavid","guid":195,"unread":true,"content":" Linus Torvalds responded Thursday to kernel developer Christoph Hellwig, who had claimed Torvalds merged Rust code into the kernel even over his objections as the original C code's maintainer. Highlights from Torvalds' response:\n\nThe fact is, the pull request you objected to DID NOT TOUCH THE DMA LAYER AT ALL. It was literally just another user of it, in a completely separate subdirectory, that didn't change the code you maintain in _any_ way, shape, or form... Honestly, what you have been doing is basically saying \"as a DMA maintainer I control what the DMA code is used for\". \n\nAnd that is not how *any* of this works. What's next? Saying that particular drivers can't do DMA, because you don't like that device, and as a DMA maintainer you control who can use the DMA code? That's _literally_ exactly what you are trying to do with the Rust code. You are saying that you disagree with Rust — which is fine, nobody has ever required you to write or read Rust code. But then you take that stance to mean that the Rust code cannot even use or interface to code you maintain... \n\nYou don't have to like Rust. You don't have to care about it. That's been made clear pretty much from the very beginning, that nobody is forced to suddenly have to learn a new language, and that people who want to work purely on the C side can very much continue to do so. So to get back to the very core of your statement: \n\n \"The document claims no subsystem is forced to take Rust\" \n\nthat is very much true. You are not forced to take any Rust code, or care about any Rust code in the DMA code. You can ignore it... \n\nYou can't have it both ways. You can't say \"I want to have nothing to do with Rust\", and then in the very next sentence say \"And that means that the Rust code that I will ignore cannot use the C interfaces I maintain\".... So when you change the C interfaces, the Rust people will have to deal with the fallout, and will have to fix the Rust bindings. That's kind of the promise here: there's that \"wall of protection\" around C developers that don't want to deal with Rust issues in the promise that they don't *have* to deal with Rust. \n\nBut that \"wall of protection\" basically goes both ways. If you don't want to deal with the Rust code, you get no *say* on the Rust code. Put another way: the \"nobody is forced to deal with Rust\" does not imply \"everybody is allowed to veto any Rust code\".\n \nTorvalds also made sure to add some kind remarks, including \"I respect you technically, and I like working with you.\"","contentLength":2522,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"AI Is Prompting an Evolution, Not Extinction, for Coders","url":"https://developers.slashdot.org/story/25/02/21/1113219/ai-is-prompting-an-evolution-not-extinction-for-coders?utm_source=rss1.0mainlinkanon&utm_medium=feed","date":1740148800,"author":"msmash","guid":217,"unread":true,"content":"AI coding assistants are reshaping software development, but they're unlikely to replace human programmers entirely, according to industry experts and developers. GitHub CEO Thomas Dohmke projects AI could soon generate 80-90% of corporate code, transforming developers into \"conductors of an AI-empowered orchestra\" who guide and direct these systems. \n\nCurrent AI coding tools, including Microsoft's GitHub Copilot, are delivering 10-30% productivity gains in business environments. At KPMG, developers report saving 4.5 hours weekly using Copilot, while venture investment in AI coding assistants tripled to $1.6 billion in 2024. The tools are particularly effective at automating routine tasks like documentation generation and legacy code translation, according to KPMG AI expert Swami Chandrasekaran. \n\nThey're also accelerating onboarding for new team members. Demand for junior developers remains soft, however, though analysts say it's premature to attribute this directly to AI adoption. Training programs like Per Scholas are already adapting, incorporating AI fundamentals alongside traditional programming basics to prepare developers for an increasingly AI-augmented workplace.","contentLength":1191,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Software Engineering Job Openings Hit Five-Year Low","url":"https://tech.slashdot.org/story/25/02/21/111216/software-engineering-job-openings-hit-five-year-low?utm_source=rss1.0mainlinkanon&utm_medium=feed","date":1740146400,"author":"msmash","guid":216,"unread":true,"content":"Software engineering job listings have plummeted to a five-year low, with postings on Indeed dropping to 65% of January 2020 levels -- a steeper decline than any other tech-adjacent field. According to data from Indeed's job aggregator, software development positions are now at 3.5x fewer vacancies compared to their mid-2022 peak and 8% lower than a year ago. \n\nThe decline appears driven by multiple factors including widespread adoption of AI coding tools -- with 75% of engineers reporting use of AI assistance -- and a broader tech industry recalibration after aggressive pandemic-era hiring. Notable tech companies like Salesforce are maintaining flat engineering headcount while reporting 30% productivity gains from AI tools, according to an analysis by software engineer Gergely Orosz. \n\nWhile the overall job market shows 10% growth since 2020, software development joins other tech-focused sectors in decline: marketing (-19%), hospitality (-18%), and banking/finance (-7%). Traditional sectors like construction (+25%), accounting (+24%), and electrical engineering (+20%) have grown significantly in the same period, he wrote. The trend extends beyond U.S. borders, with Canada showing nearly identical patterns. European markets and Australia demonstrate more resilience, though still below peak levels.","contentLength":1318,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"AI Can Write Code But Lacks Engineer's Instinct, OpenAI Study Finds","url":"https://developers.slashdot.org/story/25/02/19/1212257/ai-can-write-code-but-lacks-engineers-instinct-openai-study-finds?utm_source=rss1.0mainlinkanon&utm_medium=feed","date":1739973600,"author":"msmash","guid":215,"unread":true,"content":"Leading AI models can fix broken code, but they're nowhere near ready to replace human software engineers, according to extensive testing [PDF] by OpenAI researchers. The company's latest study put AI models and systems through their paces on real-world programming tasks, with even the most advanced models solving only a quarter of typical engineering challenges. \n\nThe research team created a test called SWE-Lancer, drawing from 1,488 actual software fixes made to Expensify's codebase, representing $1 million worth of freelance engineering work. When faced with these everyday programming tasks, the best AI model â\" Claude 3.5 Sonnet -- managed to complete just 26.2% of hands-on coding tasks and 44.9% of technical management decisions. \n\nThough the AI systems proved adept at quickly finding relevant code sections, they stumbled when it came to understanding how different parts of software interact. The models often suggested surface-level fixes without grasping the deeper implications of their changes. \n\nThe research, to be sure, used a set of complex methodologies to test the AI coding abilities. Instead of relying on simplified programming puzzles, OpenAI's benchmark uses complete software engineering tasks that range from quick $50 bug fixes to complex $32,000 feature implementations. Each solution was verified through rigorous end-to-end testing that simulated real user interactions, the researchers said.","contentLength":1432,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev"]}